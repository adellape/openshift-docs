[[apb-devel-design]]
= Design
{product-author}
{product-version]
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:
:prewrap!:

toc::[]

[[apb-devel-design-overview]]
== Overview

An link:https://github.com/fusor/ansible-playbook-bundle[Ansible Playbook Bundle
(APB)] borrows several concepts from the
link:https://github.com/projectatomic/nulecule[Nulecule] and
link:http://www.projectatomic.io/docs/atomicapp/[Atomicapp] projects, namely the
concept of a short-lived container with the sole purpose of orchestrating the
deployment of the intended application. For the case of APBs, this short-lived
container is the APB itself: a container with an
link:https://www.ansible.com/[Ansible] runtime environment plus any files
required to assist in orchestration, such as playbooks, roles, and extra
dependencies.

The
xref:../architecture/service_catalog/ansible_service_broker.adoc#arch-ansible-service-broker[OpenShift Ansible broker] (OAB) is an implementation of the Open Service Broker (OSB) API
that manages applications defined by APBs. The OAB is supported and deployed by
default starting in {product-title} 3.7.

Specification of an APB is intended to be lightweight, consisting of several
named playbooks and a metadata file to capture information such as parameters to
pass into the application.

[[apb-devel-design-workflow]]
== Workflow

The APB workflow is broken up into the following steps:

. Preparation
.. APB initialization
.. APB spec file
.. Actions (provision, deprovision, bind, unbind)
. Build
. Deploy

[[apb-devel-design-prep]]
=== Preparation

[[apb-devel-design-apb-init]]
==== APB Initialization

image::apb-prepare.png[]

The first step to creating an APB is to run the `apb init` command, which
creates the required skeleton directory structure and a few required files (for
example, the *_apb.yml_* spec file) for the APB.

The following shows an example directory structure of an APB:

[[apb-directory-structure]]
.Directory Structure
----
example-apb/
├── Dockerfile
├── apb.yml
└── roles/
│   └── example-apb-openshift
│       ├── defaults
│       │   └── main.yml
│       └── tasks
│           └── main.yml
└── playbooks/
    └── provision.yml
    └── deprovision.yml
    └── bind.yml
    └── unbind.yml
----

[[apb-devel-design-spec-file]]
==== APB Spec File

An APB spec file (*_apb.yml_*) must be edited for your specific application. For
example, the `etherpad-apb` spec file looks as follows:

----
name: fusor/etherpad-apb
description: Note taking web application
bindable: true
async: optional
metadata:
  displayName: Etherpad APB
parameters:
  - name: hostport
    description: The host TCP port as the external endpoint
    type: int
    default: 9001
  - name: db_user
    description: Database User
    type: string
----

For an APB that does not have any parameters, the `parameters` field should be
blank:

----
parameters: []
----

The `metadata` field is optional and used when integrating with the
{product-title} service catalog.

[WARNING]
====
The `bind_parameters` field is an experimental feature. The `bind_parameters`
are not required and will not be used when executing the bind action by default.
Currently, running bind returns encoded values from the provision action.

In order to use `bind_parameters` and execute the bind playbook, the OAB must
enable the feature using `LAUNCH_APB_ON_BIND=true`. In addition, Kubernetes has
not yet implemented
link:https://github.com/kubernetes-incubator/service-catalog/issues/1209[asynchronous binding], but it is expected in the near future. Until then, if the binding is
not created quickly, the request will time out with unexpected results.
====

[[apb-devel-design-actions]]
==== Actions

The following are the actions for an APB. At a minimum, an APB must implement
the provision and deprovision actions:

*_provision.yml_*::
Playbook called to handle installing application to the cluster.

*_deprovision.yml_*::
Playbook called to handle uninstalling.

*_bind.yml_*::
Playbook to grant access to another service to use this service, such as
generating credentials.

*_unbind.yml_*::
Playbook to revoke access to this service.

*_test.yml_*::
(Optional) Playbook to test the the APB is vaild.

The required named playbooks correspond to methods defined by the OSB API. For
example, when the OAB needs to provision an APB it will execute
*_provision.yml_*.

After the required named playbooks have been generated, the files can be used
directly to test management of the application. A developer may want to work
with this directory of files, make tweaks, run, repeat until they are happy with
the behavior. They can test the playbooks by invoking Ansible directly with the
playbook and any required variables.

[[apb-devel-design-build]]
=== Build

The build step is responsible for building a container image from the named
playbooks for distribution. Packaging combines a base image containing an
Ansible runtime with Ansible artifacts and any dependencies required to run the
playbooks. The result is a container image with an `ENTRYPOINT` set to take in
several arguments, one of which is the method to execute, such as provision,
deprovision, and so on.

image::apb-package.png[]

[[apb-devel-design-deploy]]
=== Deploy

Deploying an APB means invoking the container and passing in the name of the
playbook to execute along with any required variables. It is possible to invoke
the APB directly without going through the OAB. Each APB is packaged so its
`ENTRYPOINT` will invoke Ansible when run. The container is intended to be
short-lived, coming up to execute the Ansible playbook for managing the
application then exiting.

In a typical APB deploy, the APB container will provision an application by
running the *_provision.yml_* playbook which executes a deployment role. The
deployment role is responsible for creating the {product-title} resources,
perhaps through calling `oc create` commands or leveraging Ansible modules. The
end result is that the APB runs Ansible to talk to OpenShift to orchestrate the
provisioning of the intended application.

image::apb-deploy.png[]
