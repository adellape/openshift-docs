= Builds and Image Streams
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:
:prewrap!:

toc::[]

== Builds
A build is the process of transforming input parameters into a resulting object.
Most often, the process is used to transform source code into a runnable image.
A link:builds.html#buildconfig[BuildConfig] object is the definition of the
entire build process.

The OpenShift build system provides extensible support for _build strategies_
that are based on selectable types specified in the build API. There are three
link:openshift_model.html#build-strategies[build strategies] available:

- link:#docker-build[Docker build]
- link:#source-build[Source-to-Image (S2I) build]
- link:#custom-build[Custom build]

By default, Docker builds and S2I builds are supported.

The resulting object of a build depends on the builder used to create it. For
Docker and S2I builds, the resulting objects are runnable images. For Custom
builds, the resulting objects are whatever the builder image author has
specified.

For a list of build commands, see the
link:../../dev_guide/builds.html[Developer's Guide].

[#docker-build]
=== Docker Build
The Docker build strategy invokes the plain
https://docs.docker.com/reference/commandline/cli/#build[docker build] command,
and therefore expects a repository with a *_Dockerfile_* and all required
artifacts in it to produce a runnable image.

[#source-build]
=== Source-to-Image (S2I) Build
link:../../creating_images/sti.html[Source-to-Image (S2I)] is a tool for
building reproducible Docker images. It produces ready-to-run images by
injecting a user source into a docker image and assembling a new docker image.
The new image incorporates the base image (the builder) and built source, and is
ready to use with the `docker run` command. S2I supports incremental builds,
which re-use previously downloaded dependencies, previously built artifacts,
etc.

The advantages of S2I include:

[horizontal]
Image flexibility:: S2I scripts can be written to layer application code onto
almost any existing Docker image, taking advantage of the existing ecosystem.
Note that, currently, S2I relies on `tar` to inject application
source, so the image needs to be able to process tarred content.

Speed:: With S2I, the assemble process can perform a large number of complex
operations without creating a new layer at each step, resulting in a fast
process. In addition, S2I scripts can be written to re-use artifacts stored in a
previous version of the application image, rather than having to download or
build them, each time the build is run.

Patchability:: S2I allows you to rebuild the application consistently if an
underlying image needs a patch due to a security issue.

Operational efficiency:: By restricting build operations instead of allowing
arbitrary actions, such as in a *_Dockerfile_*, the PaaS operator can avoid
accidental or intentional abuses of the build system.

Operational security:: Building an arbitrary *_Dockerfile_* exposes the host
system to root privilege escalation. This can be exploited by a malicious user
because the entire docker build process is run as a user with docker privileges.
S2I restricts the operations performed as a root user, and can run the scripts
as a non-root user.

User efficiency:: S2I prevents developers from performing arbitrary `yum
install` type operations during their application build, which results in slow
development iteration.

Ecosystem:: S2I encourages a shared ecosystem of images where you can leverage
best practices for your applications.

[#custom-build]
=== Custom Build
The Custom build strategy allows developers to define a specific builder image,
responsible for the entire build process. Using your own builder image allows
you to customize your build process.

The link:../../creating_images/custom.html[Custom builder image] is a plain
Docker image with embedded build process logic, such as building RPMs or
building base Docker images. The
https://registry.hub.docker.com/u/openshift/origin-custom-docker-builder/[openshift/origin-custom-docker-builder]
image is used by default.

== Image Streams
OpenShift stores information about
link:containers_and_images.html#docker-images[docker images] and complete
metadata about the image (e.g., command, entrypoint, environment variables,
etc.). Images in OpenShift are immutable.

Like Docker, images are retrieved within the scope of an _image stream_. An
image stream is a representation of a stream of related images. Other OpenShift
components, such as builds and deployments, can watch an image stream and will
be notified when new images are added and react accordingly with performing a
new build, deployment, or both.

.Image Stream Object Definition
====

[source,json]
----
{
  "kind": "ImageStream",
  "apiVersion": "v1",
  "metadata": {
    "name": "origin-ruby-sample",
    "namespace": "p1",
    "selfLink": "/osapi/v1/namesapces/p1/imageStreams/origin-ruby-sample",
    "uid": "480dfe73-f340-11e4-97b5-001c422dcd49",
    "resourceVersion": "293",
    "creationTimestamp": "2015-05-05T16:03:34Z",
    "labels": {
      "template": "application-template-stibuild"
    }
  },
  "spec": {},
  "status": {
    "dockerImageRepository": "172.30.30.129:5000/p1/origin-ruby-sample",
    "tags": [
      {
        "tag": "latest",
        "items": [
          {
            "created": "2015-05-05T16:05:47Z",
            "dockerImageReference": "172.30.30.129:5000/p1/origin-ruby-sample@sha256:4d3a646b58685449179a0c61ad4baa19a8df8ba668e0f0704b9ad16f5e16e642",
            "image": "sha256:4d3a646b58685449179a0c61ad4baa19a8df8ba668e0f0704b9ad16f5e16e642"
          }
        ]
      }
    ]
  }
}
----

====

The `*ImageStreamImage*` object is used to retrieve an image for a given image
stream and image name. The `*ImageStreamTag*` object is used to retrieve an
image for a given image stream and tag.

The sample image below is from the *origin-ruby-sample* image stream, and can be
retrieved by asking for the `*ImageStreamImage*` with the name
*origin-ruby-sample@sha256:4d3a646b58685449179a0c61ad4baa19a8df8ba668e0f0704b9ad16f5e16e642*:

.Definition of an Image Object from an Image Stream
====

[source,json]
----
{
  "kind": "ImageStreamImage",
  "apiVersion": "v1",
  "metadata": {
    "name": "origin-ruby-sample@sha256:4d3a646b58685449179a0c61ad4baa19a8df8ba668e0f0704b9ad16f5e16e642",
    "namespace": "p1",
    "selfLink": "/osapi/v1/namespaces/p1/imageStreamImages/origin-ruby-sample@sha256:4d3a646b58685449179a0c61ad4baa19a8df8ba668e0f0704b9ad16f5e16e642",
    "uid": "979654af-f340-11e4-97b5-001c422dcd49",
    "resourceVersion": "292",
    "creationTimestamp": "2015-05-05T16:05:47Z"
  },
  "dockerImageReference": "172.30.30.129:5000/p1/origin-ruby-sample@sha256:4d3a646b58685449179a0c61ad4baa19a8df8ba668e0f0704b9ad16f5e16e642",
  "dockerImageMetadata": {
    "kind": "DockerImage",
    "apiVersion": "1.0",
    "Id": "a89ea1a1f7b20b48b1968cecd81fccc61203ceb1c9232727711c2f3dc8b7c163",
    "Parent": "94439378e4546d72ef221c47fe2ac30065bcc3a98c25bc51bed77ec00efabb95",
    "Created": "2015-05-05T16:04:27Z",
    "Container": "02ee1ea5e2b71f39afc0944bbeef10d5df2e69ecca0fba3838d2c5019731ef0f",
    "ContainerConfig": {
      "Hostname": "02ee1ea5e2b7",
      "User": "default",
      "AttachStdout": true,
      "ExposedPorts": {
        "8080/tcp": {}
      },
      "OpenStdin": true,
      "StdinOnce": true,
      "Env": [
        "RACK_ENV=production",
        "OPENSHIFT_BUILD_NAME=ruby-sample-build-1",
        "OPENSHIFT_BUILD_NAMESPACE=p1",
        "OPENSHIFT_BUILD_SOURCE=git://github.com/openshift/ruby-hello-world.git",
        "PATH=/opt/openshift/src/bin:/opt/openshift/bin:/usr/local/sti:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
        "STI_SCRIPTS_URL=image:///usr/local/sti",
        "HOME=/opt/openshift/src",
        "RUBY_VERSION=2.0",
        "IMAGE_DESCRIPTION=Ruby 2.0",
        "IMAGE_TAGS=ruby,ruby20",
        "IMAGE_EXPOSE_SERVICES=8080:http"
      ],
      "Cmd": [
        "/bin/sh",
        "-c",
        "tar -C /tmp -xf - \u0026\u0026 /usr/local/sti/assemble"
      ],
      "Image": "openshift/ruby-20-centos7:latest",
      "WorkingDir": "/opt/openshift/src"
    },
    "DockerVersion": "1.6.0",
    "Config": {
      "User": "default",
      "ExposedPorts": {
        "8080/tcp": {}
      },
      "Env": [
        "RACK_ENV=production",
        "OPENSHIFT_BUILD_NAME=ruby-sample-build-1",
        "OPENSHIFT_BUILD_NAMESPACE=p1",
        "OPENSHIFT_BUILD_SOURCE=git://github.com/openshift/ruby-hello-world.git",
        "PATH=/opt/openshift/src/bin:/opt/openshift/bin:/usr/local/sti:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
        "STI_SCRIPTS_URL=image:///usr/local/sti",
        "HOME=/opt/openshift/src",
        "RUBY_VERSION=2.0",
        "IMAGE_DESCRIPTION=Ruby 2.0",
        "IMAGE_TAGS=ruby,ruby20",
        "IMAGE_EXPOSE_SERVICES=8080:http"
      ],
      "Cmd": [
        "/usr/local/sti/run"
      ],
      "WorkingDir": "/opt/openshift/src"
    },
    "Architecture": "amd64",
    "Size": 11709626
  },
  "dockerImageMetadataVersion": "1.0",
  "imageName": ""
}
----
====

Each container in a pod has a Docker image. Once you have created an image and
pushed it to your registry, you can then refer to it in the pod.

When OpenShift creates containers, if a container's `*imagePullPolicy*`
parameter is not specified, OpenShift performs the following logic for
retrieving the image:

. If the image's tag is *latest*, OpenShift always pulls down the image from
its registry.
. If the image's tag is not *latest*, and the image exists on the node,
OpenShift runs the existing image.
. If the image's tag is not *latest*, and the image does not exist on the node,
OpenShift pulls down the image from its registry.

If the pull policy is set to *PullIfNotPresent*, OpenShift will pull the image
if it doesn't exist on the node.

If the pull policy is *PullNever*, OpenShift will never try to pull the image.

An image stream can be configured to import tag and image metadata from an image
repository in an external Docker image registry. See
link:../infrastructure_components/image_registry.html[Image Registry] for more
details.

=== Tag Tracking
An image stream can also be configured so that a tag "tracks" another one. For
example, you can configure the *latest* tag to always refer to the current image
for the tag "2.0":

====

[source,json]
----
{
  "kind": "ImageStream",
  "apiVersion": "v1",
  "metadata": {
    "name": "ruby"
  },
  "spec": {
    "tags": [
      {
        "name": "latest",
        "from": {
          "kind": "ImageStreamTag",
          "name": "2.0"
        }
      }
    ]
  }
}
----
====

=== Image Stream Mappings
When the integrated OpenShift docker registry receives a new image, a
notification is sent to OpenShift via the `*ImageStreamMapping*` route. The
registry informs OpenShift of the image's namespace, name, tag, and docker
metadata. OpenShift uses this information to create a new image and to update
the appropriate image stream with the mapping between the image's tag and the
image itself.

.Image Stream Mapping Object Definition
====

[source,json]
----
{
  "kind": "ImageStreamMapping",
  "apiVersion": "v1",
  "metadata": {
    "name": "origin-ruby-sample",
    "namespace": "test"
  },
  "image": {
    "metadata": {
      "name": "a2f15cc10423c165ca221f4a7beb1f2949fb0f5acbbc8e3a0250eb7d5593ae64"
    },
    "dockerImageReference": "172.30.17.3:5001/test/origin-ruby-sample:a2f15cc10423c165ca221f4a7beb1f2949fb0f5acbbc8e3a0250eb7d5593ae64",
    "dockerImageMetadata": {
      "kind": "DockerImage",
      "apiVersion": "1.0",
      "Id": "a2f15cc10423c165ca221f4a7beb1f2949fb0f5acbbc8e3a0250eb7d5593ae64",
      "Parent": "3bb14bfe4832874535814184c13e01527239633627cdc38f18fa186e73a6b62c",
      "Created": "2015-01-23T21:47:04Z",
      "Container": "f81db8980c62d7650683326173a361c3b09f3bc41471918b6319f7df67943b54",
      "ContainerConfig": {
        "Hostname": "f81db8980c62",
        "User": "ruby",
        "AttachStdout": true,
        "ExposedPorts": {
          "9292/tcp": {}
        },
        "OpenStdin": true,
        "StdinOnce": true,
        "Env": [
          "OPENSHIFT_BUILD_NAME=4bf65438-a349-11e4-bead-001c42c44ee1",
          "OPENSHIFT_BUILD_NAMESPACE=test",
          "OPENSHIFT_BUILD_SOURCE=git://github.com/openshift/ruby-hello-world.git",
          "PATH=/opt/ruby/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
          "STI_SCRIPTS_URL=https://raw.githubusercontent.com/openshift/sti-ruby/master/2.0/.sti/bin",
          "APP_ROOT=.",
          "HOME=/opt/ruby"
        ],
        "Cmd": [
          "/bin/sh",
          "-c",
          "tar -C /tmp -xf - \u0026\u0026 /tmp/scripts/assemble"
        ],
        "Image": "openshift/ruby-20-centos7",
        "WorkingDir": "/opt/ruby/src"
      },
      "DockerVersion": "1.4.1-dev",
      "Config": {
        "User": "ruby",
        "ExposedPorts": {
          "9292/tcp": {}
        },
        "Env": [
          "OPENSHIFT_BUILD_NAME=4bf65438-a349-11e4-bead-001c42c44ee1",
          "OPENSHIFT_BUILD_NAMESPACE=test",
          "OPENSHIFT_BUILD_SOURCE=git://github.com/openshift/ruby-hello-world.git",
          "PATH=/opt/ruby/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
          "STI_SCRIPTS_URL=https://raw.githubusercontent.com/openshift/sti-ruby/master/2.0/.sti/bin",
          "APP_ROOT=.",
          "HOME=/opt/ruby"
        ],
        "Cmd": [
          "/tmp/scripts/run"
        ],
        "WorkingDir": "/opt/ruby/src"
      },
      "Architecture": "amd64",
      "Size": 11710004
    },
    "dockerImageMetadataVersion": "1.0"
  },
  "tag": "latest"
}
----
====
